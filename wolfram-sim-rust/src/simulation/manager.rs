use std::collections::HashMap;
use serde::{Serialize, Deserialize};

use crate::hypergraph::{Hypergraph, AtomId, RelationId};
use crate::rules::{Rule, rule::RuleSet, RuleId};
use crate::matching::find_pattern_matches;
use crate::evolution::apply_rule;
use super::event::{SimulationEvent, HypergraphState};

/// Result of a simulation step operation.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct StepResult {
    /// Whether a rule was successfully applied
    pub success: bool,
    
    /// The event generated by this step (if successful)
    pub event: Option<SimulationEvent>,
    
    /// Current state of the hypergraph after the step
    pub hypergraph_state: HypergraphState,
    
    /// Optional message describing the result
    pub message: Option<String>,
}

impl StepResult {
    /// Creates a successful step result.
    pub fn success(event: SimulationEvent, hypergraph_state: HypergraphState) -> Self {
        StepResult {
            success: true,
            event: Some(event),
            hypergraph_state,
            message: None,
        }
    }
    
    /// Creates a failed step result (no applicable rules).
    pub fn no_rules_applicable(hypergraph_state: HypergraphState) -> Self {
        StepResult {
            success: false,
            event: None,
            hypergraph_state,
            message: Some("No applicable rules found".to_string()),
        }
    }
    
    /// Creates a step result with a custom message.
    pub fn with_message(mut self, message: String) -> Self {
        self.message = Some(message);
        self
    }
}

/// Configuration for continuous simulation.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ContinuousSimulationConfig {
    /// Maximum number of steps to run (None for unlimited)
    pub max_steps: Option<u64>,
    
    /// Stop simulation when no more rules can be applied
    pub stop_on_fixed_point: bool,
    
    /// Optional step interval for reporting progress (0 = report every step)
    pub report_interval: u64,
}

impl Default for ContinuousSimulationConfig {
    fn default() -> Self {
        ContinuousSimulationConfig {
            max_steps: Some(1000), // Default limit to prevent infinite loops
            stop_on_fixed_point: true,
            report_interval: 0, // Report every step by default
        }
    }
}

/// Result of a continuous simulation run.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ContinuousSimulationResult {
    /// Total number of steps executed
    pub steps_executed: u64,
    
    /// All events generated during the simulation
    pub events: Vec<SimulationEvent>,
    
    /// Final state of the hypergraph
    pub final_state: HypergraphState,
    
    /// Reason why the simulation stopped
    pub stop_reason: StopReason,
}

/// Reasons why a continuous simulation might stop.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum StopReason {
    /// Reached the maximum number of steps
    MaxStepsReached,
    
    /// No more rules can be applied (fixed point)
    FixedPointReached,
    
    /// Simulation was manually stopped
    ManualStop,
}

/// The main simulation manager that handles the evolution of the hypergraph.
/// This implements the simulation loop logic as specified in F1.5.
#[derive(Debug)]
pub struct SimulationManager {
    /// The current hypergraph being simulated
    hypergraph: Hypergraph,
    
    /// The set of rules that can be applied
    rule_set: RuleSet,
    
    /// Current step number
    step_number: u64,
    
    /// Event selection strategy (for MVP, we use deterministic "first match")
    event_selection_strategy: EventSelectionStrategy,
}

/// Strategy for selecting which rule to apply when multiple matches are available.
/// For MVP, we implement a simple deterministic strategy.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum EventSelectionStrategy {
    /// Apply the first rule that has at least one match
    FirstRuleFirstMatch,
    
    /// Apply the rule with the most matches available
    MostMatches,
}

impl Default for EventSelectionStrategy {
    fn default() -> Self {
        EventSelectionStrategy::FirstRuleFirstMatch
    }
}

impl SimulationManager {
    /// Creates a new simulation manager with an empty hypergraph and basic rule set.
    pub fn new() -> Self {
        SimulationManager {
            hypergraph: Hypergraph::new(),
            rule_set: RuleSet::create_basic_ruleset(),
            step_number: 0,
            event_selection_strategy: EventSelectionStrategy::default(),
        }
    }
    
    /// Creates a new simulation manager with a custom hypergraph and rule set.
    pub fn with_hypergraph_and_rules(hypergraph: Hypergraph, rule_set: RuleSet) -> Self {
        SimulationManager {
            hypergraph,
            rule_set,
            step_number: 0,
            event_selection_strategy: EventSelectionStrategy::default(),
        }
    }
    
    /// Creates a new simulation manager from a saved hypergraph state.
    pub fn from_state(state: &HypergraphState, rule_set: RuleSet) -> Result<Self, String> {
        let mut hypergraph = Hypergraph::new();
        
        // Restore the ID counters
        hypergraph.set_next_atom_id(state.next_atom_id());
        hypergraph.set_next_relation_id(state.next_relation_id());
        
        // Add all atoms
        for atom in state.atoms() {
            hypergraph.add_atom(atom.clone());
        }
        
        // Add all relations
        for relation in state.relations() {
            hypergraph.add_relation(relation.clone());
        }
        
        Ok(SimulationManager {
            hypergraph,
            rule_set,
            step_number: state.step_number(),
            event_selection_strategy: EventSelectionStrategy::default(),
        })
    }
    
    /// Returns the current hypergraph state.
    pub fn get_current_state(&self) -> HypergraphState {
        HypergraphState::new(
            self.hypergraph.get_all_atoms(),
            self.hypergraph.get_all_relations(),
            self.step_number,
            self.hypergraph.next_atom_id(),
            self.hypergraph.next_relation_id(),
        )
    }
    
    /// Returns a reference to the current hypergraph.
    pub fn hypergraph(&self) -> &Hypergraph {
        &self.hypergraph
    }
    
    /// Returns a mutable reference to the current hypergraph.
    pub fn hypergraph_mut(&mut self) -> &mut Hypergraph {
        &mut self.hypergraph
    }
    
    /// Returns the current step number.
    pub fn step_number(&self) -> u64 {
        self.step_number
    }
    
    /// Returns a reference to the rule set.
    pub fn rule_set(&self) -> &RuleSet {
        &self.rule_set
    }
    
    /// Sets the event selection strategy.
    pub fn set_event_selection_strategy(&mut self, strategy: EventSelectionStrategy) {
        self.event_selection_strategy = strategy;
    }
    
    /// Executes a single simulation step.
    /// This implements the core simulation loop logic: match, select, apply.
    pub fn step(&mut self) -> StepResult {
        // Find all possible matches for all rules
        let mut all_matches = Vec::new();
        
        for rule in self.rule_set.iter() {
            let matches = find_pattern_matches(rule.pattern(), &self.hypergraph);
            if !matches.is_empty() {
                all_matches.push((rule, matches));
            }
        }
        
        // If no matches found, simulation cannot proceed
        if all_matches.is_empty() {
            return StepResult::no_rules_applicable(self.get_current_state());
        }
        
        // Select which rule and match to apply based on strategy
        let (selected_rule, selected_match) = self.select_event(&all_matches);
        
        // Apply the selected rule
        let rewrite_result = apply_rule(&mut self.hypergraph, selected_rule, selected_match);
        
        // Increment step number
        self.step_number += 1;
        
        // Create simulation event
        let event = SimulationEvent::with_description(
            self.step_number,
            selected_rule.id(),
            rewrite_result.new_atoms,
            rewrite_result.new_relations,
            rewrite_result.removed_relations,
            format!("Applied rule {} at step {}", selected_rule.id().value(), self.step_number),
        );
        
        let current_state = self.get_current_state();
        
        StepResult::success(event, current_state)
    }
    
    /// Executes multiple simulation steps.
    pub fn step_multiple(&mut self, num_steps: u64) -> Vec<StepResult> {
        let mut results = Vec::new();
        
        for _ in 0..num_steps {
            let result = self.step();
            let should_continue = result.success;
            results.push(result);
            
            if !should_continue {
                break;
            }
        }
        
        results
    }
    
    /// Runs the simulation continuously until a stopping condition is met.
    pub fn run_continuous(&mut self, config: ContinuousSimulationConfig) -> ContinuousSimulationResult {
        let mut events = Vec::new();
        let mut steps_executed = 0;
        
        loop {
            // Check if we've reached the maximum steps
            if let Some(max_steps) = config.max_steps {
                if steps_executed >= max_steps {
                    return ContinuousSimulationResult {
                        steps_executed,
                        events,
                        final_state: self.get_current_state(),
                        stop_reason: StopReason::MaxStepsReached,
                    };
                }
            }
            
            // Execute one step
            let step_result = self.step();
            steps_executed += 1;
            
            if step_result.success {
                if let Some(event) = step_result.event {
                    events.push(event);
                }
            } else {
                // No more rules applicable - fixed point reached
                if config.stop_on_fixed_point {
                    return ContinuousSimulationResult {
                        steps_executed,
                        events,
                        final_state: step_result.hypergraph_state,
                        stop_reason: StopReason::FixedPointReached,
                    };
                }
                // If not stopping on fixed point, we still can't proceed
                break;
            }
        }
        
        ContinuousSimulationResult {
            steps_executed,
            events,
            final_state: self.get_current_state(),
            stop_reason: StopReason::FixedPointReached,
        }
    }
    
    /// Resets the simulation to an empty state.
    pub fn reset(&mut self) {
        self.hypergraph.clear();
        self.step_number = 0;
    }
    
    /// Loads a new hypergraph state, replacing the current one.
    pub fn load_state(&mut self, state: &HypergraphState) -> Result<(), String> {
        // Create a new hypergraph and populate it
        let mut new_hypergraph = Hypergraph::new();
        
        // Restore the ID counters
        new_hypergraph.set_next_atom_id(state.next_atom_id());
        new_hypergraph.set_next_relation_id(state.next_relation_id());
        
        // Add all atoms
        for atom in state.atoms() {
            new_hypergraph.add_atom(atom.clone());
        }
        
        // Add all relations
        for relation in state.relations() {
            new_hypergraph.add_relation(relation.clone());
        }
        
        // Replace current state
        self.hypergraph = new_hypergraph;
        self.step_number = state.step_number();
        
        Ok(())
    }
    
    /// Selects which event (rule + match) to apply based on the current strategy.
    fn select_event<'a>(
        &self,
        all_matches: &'a [(&Rule, Vec<crate::matching::PatternMatch>)],
    ) -> (&'a Rule, &'a crate::matching::PatternMatch) {
        match self.event_selection_strategy {
            EventSelectionStrategy::FirstRuleFirstMatch => {
                // Simply take the first rule that has matches and its first match
                let (rule, matches) = &all_matches[0];
                (rule, &matches[0])
            }
            EventSelectionStrategy::MostMatches => {
                // Find the rule with the most matches
                let (rule, matches) = all_matches
                    .iter()
                    .max_by_key(|(_, matches)| matches.len())
                    .unwrap();
                (rule, &matches[0])
            }
        }
    }
}

impl Default for SimulationManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::hypergraph::{Atom, Relation};
    use crate::rules::Rule;

    #[test]
    fn test_simulation_manager_creation() {
        let manager = SimulationManager::new();
        assert_eq!(manager.step_number(), 0);
        assert_eq!(manager.hypergraph().atom_count(), 0);
        assert_eq!(manager.hypergraph().relation_count(), 0);
    }
    
    #[test]
    fn test_simulation_step_with_basic_edge_splitting() {
        let mut manager = SimulationManager::new();
        
        // Create a simple hypergraph with one edge: A -- B
        let atom_a = manager.hypergraph_mut().create_atom();
        let atom_b = manager.hypergraph_mut().create_atom();
        let _relation_ab = manager.hypergraph_mut().create_relation(vec![atom_a, atom_b]);
        
        // Verify initial state
        assert_eq!(manager.hypergraph().atom_count(), 2);
        assert_eq!(manager.hypergraph().relation_count(), 1);
        assert_eq!(manager.step_number(), 0);
        
        // Execute one step
        let result = manager.step();
        
        // Verify step was successful
        assert!(result.success);
        assert!(result.event.is_some());
        
        let event = result.event.unwrap();
        assert_eq!(event.step_number(), 1);
        assert_eq!(event.atoms_created().len(), 1); // One new atom created
        assert_eq!(event.relations_created().len(), 2); // Two new relations
        assert_eq!(event.relations_removed().len(), 1); // One relation removed
        
        // Verify final state
        assert_eq!(manager.step_number(), 1);
        assert_eq!(manager.hypergraph().atom_count(), 3); // A, B, + new atom
        assert_eq!(manager.hypergraph().relation_count(), 2); // Two new relations
    }
    
    #[test]
    fn test_simulation_step_no_applicable_rules() {
        let mut manager = SimulationManager::new();
        
        // Create an empty hypergraph (no relations to match)
        let _atom_a = manager.hypergraph_mut().create_atom();
        
        // Execute one step
        let result = manager.step();
        
        // Should fail because no relations exist to match the edge splitting rule
        assert!(!result.success);
        assert!(result.event.is_none());
        assert_eq!(result.message, Some("No applicable rules found".to_string()));
        assert_eq!(manager.step_number(), 0); // Step number shouldn't increment on failure
    }
    
    #[test]
    fn test_multiple_steps() {
        let mut manager = SimulationManager::new();
        
        // Create initial edge
        let atom_a = manager.hypergraph_mut().create_atom();
        let atom_b = manager.hypergraph_mut().create_atom();
        let _relation_ab = manager.hypergraph_mut().create_relation(vec![atom_a, atom_b]);
        
        // Execute multiple steps
        let results = manager.step_multiple(3);
        
        // All steps should be successful (edge splitting creates more edges to split)
        assert!(results.iter().all(|r| r.success));
        assert_eq!(results.len(), 3);
        assert_eq!(manager.step_number(), 3);
    }
    
    #[test]
    fn test_continuous_simulation() {
        let mut manager = SimulationManager::new();
        
        // Create initial edge
        let atom_a = manager.hypergraph_mut().create_atom();
        let atom_b = manager.hypergraph_mut().create_atom();
        let _relation_ab = manager.hypergraph_mut().create_relation(vec![atom_a, atom_b]);
        
        // Run continuous simulation with limited steps
        let config = ContinuousSimulationConfig {
            max_steps: Some(5),
            stop_on_fixed_point: true,
            report_interval: 1,
        };
        
        let result = manager.run_continuous(config);
        
        assert_eq!(result.steps_executed, 5);
        assert_eq!(result.events.len(), 5);
        assert_eq!(result.stop_reason, StopReason::MaxStepsReached);
        assert_eq!(manager.step_number(), 5);
    }
    
    #[test]
    fn test_get_and_load_state() {
        let mut manager = SimulationManager::new();
        
        // Create some state
        let atom_a = manager.hypergraph_mut().create_atom();
        let atom_b = manager.hypergraph_mut().create_atom();
        let _relation_ab = manager.hypergraph_mut().create_relation(vec![atom_a, atom_b]);
        
        // Execute a step to advance the state
        let _result = manager.step();
        
        // Get current state
        let state = manager.get_current_state();
        assert_eq!(state.step_number(), 1);
        assert_eq!(state.atoms().len(), 3); // Original 2 + 1 created
        assert_eq!(state.relations().len(), 2); // 2 new relations after edge split
        
        // Reset and reload state
        manager.reset();
        assert_eq!(manager.step_number(), 0);
        assert_eq!(manager.hypergraph().atom_count(), 0);
        
        let result = manager.load_state(&state);
        assert!(result.is_ok());
        assert_eq!(manager.step_number(), 1);
        assert_eq!(manager.hypergraph().atom_count(), 3);
        assert_eq!(manager.hypergraph().relation_count(), 2);
    }
    
    #[test]
    fn test_event_selection_strategies() {
        let mut manager = SimulationManager::new();
        
        // Test that different strategies can be set
        manager.set_event_selection_strategy(EventSelectionStrategy::FirstRuleFirstMatch);
        manager.set_event_selection_strategy(EventSelectionStrategy::MostMatches);
        
        // For comprehensive testing of strategy behavior, we'd need multiple rules
        // For now, just verify the strategies can be set without error
    }
} 